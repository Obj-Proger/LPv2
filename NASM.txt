Netwide Assembler (NASM)
__________________________________________________
1. Введение в архитектуру Intel x86-64 и ассемблер NASM

Архитектура Intel x86-64

Архитектура x86:
	Адреса, регистры и АЛУ имеют разрядность 32 бита
	Инструкции работали с операндами размером до 32 бит

Архитектура х64 (совместимое 64-битное расширение 32-битной архитектуры x86):
	Адреса, РОНы были расширены до 64 бит
	Добавлены регистры R8-R15
	Добавлена встроенная поддержка для 64-битных целых чисел
___________
Представление данных, биты и байты

Бит - наименьшая единица измерения информации(Имеет 2 состояния: 1/0)
Байт - битовое поле из 8 битов (Имеет 256 значений)
Регистр - ячейка памяти внутри процессора
Флаг - отдельные биты/битовые поля, имеющие особое назначения для процессора(Хранятся в регистре EFLAGS(64бит))

Для указания системы счисления указываются префиксы:
0x16ричное
0b2ичное

Представление отрицательных чисел:
	Старший байт обозначает знак:
		0 - положительное
		1 - отрицательное
	
Простой способ получить число с противоположным знаком:
	Инвертировать биты (0 поменять на 1, а 1 на 0)
	Добавить 1
___________
Регистры процессора

Все регистры x86-64 имеют свое особое назначение, которое ограничивает их использование в определенных контекстах

Регистры общего назначения:
RAX(64бит) - (Accumulator): для арифметических операций
	EAX(32бит) - Младшая часть RAX(0-31)
	AX(16бит) - Младшая часть EAX(0-15)
	AH(8бит) - Старшая часть AX(8-15)
	AL(8бит) - Младшая часть AX(0-7)
RBX(64бит) - (Base): указатель на данные
	EBX(32бит) - Младшая часть RBX(0-31)
	BX(16бит) - Младшая часть EBX(0-15)
	BH(8бит) - Старшая часть BX(0-31)
	BL(8бит) - Младшая часть BX(0-7)
RCX(64бит) - (Counter): для хранения счетчика цикла
	ECX(32бит) - Младшая часть RCX(0-31)
	CX(16бит) - Младшая часть ECX(0-15)
	CH(8бит) - Старшая часть CX(0-31)
	CL(8бит) - Младшая часть CX(0-7)
RDX(64бит) - (Data): для арифметических операций и операций ввода-вывода
	EDX(32бит) - Младшая часть RDX(0-31)
	DX(16бит) - Младшая часть EDX(0-15)
	DH(8бит) - Старшая часть DX(0-31)
	DL(8бит) - Младшая часть DX(0-7)
RSI(64бит) - (Source index): указатель на источник при операциях с массивом
	ESI(32бит) - Младшая часть RSI(0-31)
	SI(16бит) - Младшая часть ESI(0-15)
RDI(64бит) - (Destination index): указатель на место назначения в операциях с массивами
	EDI(32бит) - Младшая часть RDI(0-31)
	DI(16бит) - Младшая часть EDI(0-15)
RBP(64бит) - (Base pointer): указатель на базу стека внутри функции
	EBP(32бит) - Младшая часть RBP(0-31)
	BP(16бит) - Младшая часть EBP(0-15)
RSP(64бит) - (Stack pointer): указатель на верхушку стека
	ESP(32бит) - Младшая часть RSP(0-31)
	SP(16бит) - Младшая часть ESP(0-15)

Сегментные регистры:
CS(32бит)
DS(32бит)
SS(32бит)
ES(32бит)
FS(32бит)
GS(32бит)

Регистр-указатель команд:
EIP(64бит): указатель адреса следующей инструкции для выполнения

Регистр флагов:
EFLAGS(64бит): регистр флагов, содержит биты состояния процессора
___________
Первая программа на Linux

global _start           ; делаем метку _start видимой извне
 
section .text           ; объявление секции кода
_start:                 ; объявление метки _start - точки входа в программу (_start = _main)
    mov rax, 60         ; 60 - номер системного вызова exit 
    mov rdi, 0			; произвольный код возврата - 0
    syscall             ; выполняем системный вызов exit
___________
Первая программа на Windows

global _start       ; делаем метку _start видимой извне 
 
section .text       ; объявление секции кода
_start:             ; метка _start - точка входа в программу (_start = _main)
    mov rax, 0     	; произвольный код возврата - 0
    ret             ; выход из программы
___________
Первая программа на MacOS

global _start           ; делаем метку метку _start видимой извне
 
section .text           ; объявление секции кода
align 4                 ; для программ для MacOS необходимо выравнивание
_start:                 ; объявление метки _start - точки входа в программу
    mov rax, 0x02000001 ; 1 - номер системного вызова exit 
    mov rdi, 22         ; произвольный код возврата - 22 
    syscall             ; выполняем системный вызов exit
__________________________________________________
Глава 2. Основы ассемблера NASM

Инструкция MOV. Копирование данных

Чтение представления команд:
Команда операнд_1, операнд_2, операнд_3
r - регистр
m - переменная
imm - константа
32 - разрядность
:= хранит значение

Команда MOV: копирует данные в destination из source
	mov destination, source
	mov r(8-64), r/m/imm(8-64)	;r:= source
	mov m(8-64), r/imm(8-64)	;m:= source
	Ограничения:
		destination должен вмещать source
		разрядность source должна совпадать с destination
		
Команда MOVZX: копирует данные в destination из source с беззнаковым расширением
	movzxd r64, r/m/imm32			;r:= source (Старшая часть расширяется 0)
	movzxd m64, r/imm32				;m:= source (Старшая часть расширяется 0)
	movzx r(16-64), r/m/imm(8-32)	;r:= source (Старшая часть расширяется 0)
	movzx m(16-64), r/imm(8-32)		;m:= source (Старшая часть расширяется 0)
	Ограничения:
		destination должен вмещать и быть больше source
		
Команда MOVSX: копирует данные в destination из source с знаковым расширением
	movsxd r64, r/m/imm32			;r:= source (Старшая часть расширяется F)
	movsxd m64, r/imm32				;m:= source (Старшая часть расширяется F)
	movsx r(16-64), r/m/imm(8-32)	;r:= source (Старшая часть расширяется F)
	movsx m(16-64), r/imm(8-32)		;m:= source (Старшая часть расширяется F)
	Ограничения:
		destination должен вмещать и быть больше source
___________
Сложение и вычитание

Команда ADD: выполняет сложение значений обоих операндов и записывает результат в операнд_1
	add операнд_1, операнд_2	;операнд_1:= операнд_1 + операнд_2

Команда SUB: выполняет вычитание втоого операнда из первого и записывает результат в операнд_1
	sub операнд_1, операнд_2	;операнд_1:= операнд_1 - операнд_2
	
Команда INC: выполняет увеличение значения операнда на 1 и записывает результат в операнд_1
	inc операнд_1, 	;операнд_1:= операнд_1 + 1

Команда DEC: выполняет уменьшение значения операнда на 1 и записывает результат в операнд_1
	dec операнд_1, 	;операнд_1:= операнд_1 - 1
___________
Переходы. Инструкция jmp

Команда JMP: выполняет безусловный переход, изменяя ход выполнения программы
	jmp метка				;метка должна существовать
	jmp регистр				;регистр должен хранить адрес перехода (mov регистр, адрес перехода)
	jmp [адрес_в_памяти]	;переменная должна хранить адрес перехода (переменная: адрес перехода)
___________
Флаги состояния и условные переходы

Флаги состояния:
	CF(1бит) - (Carry): устанавливается, если происходит беззнаковое переполнение
	OF(1бит) - (Overflow): устанавливается, если происходит переполнение со знаком (переполняется бит, следующий за старшим знаковым битом)
	SF(1бит) - (Sign): устанавливается, если старший бит результата установлен (флаг знака отражает состояние старшего бита результата)
	ZF(1бит) - (Zero): устанавливается, если результат вычисления дает 0
	
Команды условного перехода:
	Команда JC: выполняет переход к метке, если CF = 1
		jc метка/регистр/[адрес_в_памяти]
	Команда JNC: выполняет переход к метке, если CF = 0
		jnc метка/регистр/[адрес_в_памяти]
	Команда JO: выполняет переход к метке, если OF = 1
		jo метка/регистр/[адрес_в_памяти]
	Команда JNO: выполняет переход к метке, если OF = 0
		jno метка/регистр/[адрес_в_памяти]
	Команда JS: выполняет переход к метке, если SF = 1
		js метка/регистр/[адрес_в_памяти]
	Команда JNS: выполняет переход к метке, если SF = 0
		jns метка/регистр/[адрес_в_памяти]
	Команда JZ: выполняет переход к метке, если ZF = 1
		jz метка/регистр/[адрес_в_памяти]
	Команда JNZ: выполняет переход к метке, если ZF = 0
		jnz метка/регистр/[адрес_в_памяти]
		
Управление флагами:
	Команда CLC: сбрасывает в 0 флаг переноса (CF)
		clc		;CF:= 0
	Команда SETC: устанавливает флаг переноса (CF)
		setc	;CF:= 1
	Команда LAHF: копирует флаги состояния из регистра eflags в регистр ah
		lahf	;AH:= EFLAGS
	Команда SAHF: сохраняет флаги состояния из регистра ah в регистр eflags
		sahf	;EfLAGS:= AH
		
Инструкции lahf и sahf применяют следующий порядок битов для флагов, начиная с младшего бита:
	0:=	Флаг переноса (CF)
	1:=Всегда равен 1 (не используется)
	2:=Флаг паритетности (PF)
	3:=Всегда равен 0 (не используется)
	4:=Дополнительный флаг переноса (AF)
	5:=Всегда равен 0 (не используется)
	6:=Флаг нуля (ZF)
	7:=Флаг знака (SF)
___________
Сравнение. Инструкция CMP
___________
Инструкции условного копирования
___________
Инструкция цикла loop и jrcxz
___________
Умножение. Инструкции mul и imul
___________
Деление. Инструкции div и idiv
___________
Логические операции
___________
Сдвиг и вращение
__________________________________________________
Глава 3. Работа с данными и памятью

Определение переменных и типы данных. Секция .data
___________
Косвенная адресация
___________
Получение текущего адреса
___________
Константы
___________
Символы
___________
Строки
___________
Порядок байтов. Big-endian и little-endian
___________
Структуры
___________
Стек
___________
Копирование и сохранение в строку
___________
Сравнение строк
___________
Поиск в строке
__________________________________________________
Глава 4. Функции

Определение и вызов функций
___________
Сохранение регистров и переменных при вызове функций
___________
Параметры функции
___________
Результат функции
___________
Фрейм стека и локальные переменные
___________
Локальные метки
___________
Организация программы
__________________________________________________
Глава 5. Системные вызовы

Системные вызовы в Linux и инструкция syscall
___________
Системные вызовы и прерывания

Глава 6. Взаимодействие кода ассемблера и C/C++

Вызов функций C/C++ из ассемблера на Linux

Вызов функций C/C++ из ассемблера на Windows

Вызов функции ассемблера из C/C++

Передача структур между ассемблером и C/C++

Работа с файлами
__________________________________________________
Глава 7. SIMD

Числа с плавающей точкой

Расширения SSE и AVX/AVX2

Копирование данных с помощью инструкций SIMD

Преобразование чисел с плавающей точкой в целые числа и обратно

Арифметика чисел с плавающей точкой

Сравнение чисел с плавающей точкой

Операции сдвига SSE/AVX

Логические операции над векторами

Сложение с помощью инструкций SSE/AVX

Вычитание с помощью инструкций SSE/AVX

Умножение с помощью инструкций SSE/AVX

Математические инструкции SSE/AVX

Сравнение целых чисел в SSE/AVX

Арифметические операции с векторами чисел с плавающей точкой

Сохранение состояния регистров SSE/AVX
__________________________________________________
Глава 8. Препроцессор

Директивы препроцессора

Условные конструкции препроцессора

Макросы
__________________________________________________
Глава 9. Разделяемые библиотеки в Linux

Создание разделяемых библиотек для Linux

Код, независимый от позиции

Подключение встроенных библиотек Linux

Переопределение общих библиотек

Программная загрузка библиотек
__________________________________________________
Глава 10. Дополнительные статьи

Стек, аргументы программы и переменные окружения в Linux

Манипуляции с консолью и курсором

Реализация конечных автоматов


























