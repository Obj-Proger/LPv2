Netwide Assembler (NASM)
__________________________________________________
1. Введение в архитектуру Intel x86-64 и ассемблер NASM

Архитектура Intel x86-64

Архитектура x86:
	Адреса, регистры и АЛУ имеют разрядность 32 бита
	Инструкции работали с операндами размером до 32 бит

Архитектура х64 (совместимое 64-битное расширение 32-битной архитектуры x86):
	Адреса, РОНы были расширены до 64 бит
	Добавлены регистры R8-R15
	Добавлена встроенная поддержка для 64-битных целых чисел
___________
Представление данных, биты и байты

Бит - наименьшая единица измерения информации(Имеет 2 состояния: 1/0)
Байт - битовое поле из 8 битов (Имеет 256 значений)
Регистр - ячейка памяти внутри процессора
Флаг - отдельные биты/битовые поля, имеющие особое назначения для процессора(Хранятся в регистре EFLAGS(64бит))

Для указания системы счисления указываются префиксы:
0x16ричное
0b2ичное

Представление отрицательных чисел:
	Старший байт обозначает знак:
		0 - положительное
		1 - отрицательное
	
Простой способ получить число с противоположным знаком:
	Инвертировать биты (0 поменять на 1, а 1 на 0)
	Добавить 1
___________
Регистры процессора

Все регистры x86-64 имеют свое особое назначение, которое ограничивает их использование в определенных контекстах

Регистры общего назначения:
RAX(64бит) - (Accumulator): для арифметических операций
	EAX(32бит) - Младшая часть RAX(0-31)
	AX(16бит) - Младшая часть EAX(0-15)
	AH(8бит) - Старшая часть AX(8-15)
	AL(8бит) - Младшая часть AX(0-7)
RBX(64бит) - (Base): указатель на данные
	EBX(32бит) - Младшая часть RBX(0-31)
	BX(16бит) - Младшая часть EBX(0-15)
	BH(8бит) - Старшая часть BX(0-31)
	BL(8бит) - Младшая часть BX(0-7)
RCX(64бит) - (Counter): для хранения счетчика цикла
	ECX(32бит) - Младшая часть RCX(0-31)
	CX(16бит) - Младшая часть ECX(0-15)
	CH(8бит) - Старшая часть CX(0-31)
	CL(8бит) - Младшая часть CX(0-7)
RDX(64бит) - (Data): для арифметических операций и операций ввода-вывода
	EDX(32бит) - Младшая часть RDX(0-31)
	DX(16бит) - Младшая часть EDX(0-15)
	DH(8бит) - Старшая часть DX(0-31)
	DL(8бит) - Младшая часть DX(0-7)
RSI(64бит) - (Source index): указатель на источник при операциях с массивом
	ESI(32бит) - Младшая часть RSI(0-31)
	SI(16бит) - Младшая часть ESI(0-15)
RDI(64бит) - (Destination index): указатель на место назначения в операциях с массивами
	EDI(32бит) - Младшая часть RDI(0-31)
	DI(16бит) - Младшая часть EDI(0-15)
RBP(64бит) - (Base pointer): указатель на базу стека внутри функции
	EBP(32бит) - Младшая часть RBP(0-31)
	BP(16бит) - Младшая часть EBP(0-15)
RSP(64бит) - (Stack pointer): указатель на верхушку стека
	ESP(32бит) - Младшая часть RSP(0-31)
	SP(16бит) - Младшая часть ESP(0-15)

Сегментные регистры:
CS(32бит)
DS(32бит)
SS(32бит)
ES(32бит)
FS(32бит)
GS(32бит)

Регистр-указатель команд:
RIP(64бит): указатель адреса следующей инструкции для выполнения

Регистр флагов:
EFLAGS(64бит): регистр флагов, содержит биты состояния процессора
___________
Первая программа на Linux

global _start           ; делаем метку _start видимой извне
 
section .text           ; объявление секции кода
_start:                 ; объявление метки _start - точки входа в программу (_start = _main)
    mov rax, 60         ; 60 - номер системного вызова exit 
    mov rdi, 0			; произвольный код возврата - 0
    syscall             ; выполняем системный вызов exit
___________
Первая программа на Windows

global _start       ; делаем метку _start видимой извне 
 
section .text       ; объявление секции кода
_start:             ; метка _start - точка входа в программу (_start = _main)
    mov rax, 0     	; произвольный код возврата - 0
    ret             ; выход из программы
___________
Первая программа на MacOS

global _start           ; делаем метку метку _start видимой извне
 
section .text           ; объявление секции кода
align 4                 ; для программ для MacOS необходимо выравнивание
_start:                 ; объявление метки _start - точки входа в программу
    mov rax, 0x02000001 ; 1 - номер системного вызова exit 
    mov rdi, 22         ; произвольный код возврата - 22 
    syscall             ; выполняем системный вызов exit
__________________________________________________
2. Основы ассемблера NASM

Инструкция MOV. Копирование данных

Чтение представления команд:
Команда операнд_1, операнд_2, операнд_3
r - регистр
m - переменная
imm - константа
32 - разрядность
:= хранит значение

Команда MOV: копирует данные в destination из source
	mov destination, source		;destination:= source
	mov r(8-64), r/m/imm(8-64)	;r:= source
	mov m(8-64), r/imm(8-64)	;m:= source
	Ограничения:
		destination должен вмещать source
		разрядность source должна совпадать с destination
		destination и source не должны быть одновременно переменными
		
Команда MOVZX: копирует данные в destination из source с беззнаковым расширением
	movzxd r64, r/m/imm32			;r:= source (Старшая часть расширяется 0)
	movzxd m64, r/imm32				;m:= source (Старшая часть расширяется 0)
	movzx r(16-64), r/m/imm(8-32)	;r:= source (Старшая часть расширяется 0)
	movzx m(16-64), r/imm(8-32)		;m:= source (Старшая часть расширяется 0)
	Ограничения:
		destination должен вмещать и быть больше source
		
Команда MOVSX: копирует данные в destination из source с знаковым расширением
	movsxd r64, r/m/imm32			;r:= source (Старшая часть расширяется F)
	movsxd m64, r/imm32				;m:= source (Старшая часть расширяется F)
	movsx r(16-64), r/m/imm(8-32)	;r:= source (Старшая часть расширяется F)
	movsx m(16-64), r/imm(8-32)		;m:= source (Старшая часть расширяется F)
	Ограничения:
		destination должен вмещать и быть больше source
___________
Сложение и вычитание

Команда ADD: выполняет сложение значений обоих операндов и записывает результат в операнд_1
	add операнд_1, операнд_2	;операнд_1:= операнд_1 + операнд_2

Команда SUB: выполняет вычитание втоого операнда из первого и записывает результат в операнд_1
	sub операнд_1, операнд_2	;операнд_1:= операнд_1 - операнд_2
	
Команда INC: выполняет увеличение значения операнда на 1 и записывает результат в операнд_1
	inc операнд_1, 	;операнд_1:= операнд_1 + 1

Команда DEC: выполняет уменьшение значения операнда на 1 и записывает результат в операнд_1
	dec операнд_1, 	;операнд_1:= операнд_1 - 1
___________
Переходы. Инструкция jmp

Команда JMP: выполняет безусловный переход, изменяя ход выполнения программы
	jmp метка				;метка должна существовать
	jmp регистр				;регистр должен хранить адрес перехода (mov регистр, адрес перехода)
	jmp [адрес_в_памяти]	;переменная должна хранить адрес перехода (переменная: адрес перехода)
___________
Флаги состояния и условные переходы

Флаги состояния:
	CF(1бит) - (Carry): устанавливается, если происходит беззнаковое переполнение
	OF(1бит) - (Overflow): устанавливается, если происходит переполнение со знаком (переполняется бит, следующий за старшим знаковым битом)
	SF(1бит) - (Sign): устанавливается, если старший бит результата установлен (флаг знака отражает состояние старшего бита результата)
	ZF(1бит) - (Zero): устанавливается, если результат вычисления дает 0
	
Команды условного перехода:
	Команда JC: выполняет переход к метке, если CF == 1
		jc метка/регистр/[адрес_в_памяти]
	Команда JNC: выполняет переход к метке, если CF == 0
		jnc метка/регистр/[адрес_в_памяти]
	Команда JO: выполняет переход к метке, если OF == 1
		jo метка/регистр/[адрес_в_памяти]
	Команда JNO: выполняет переход к метке, если OF == 0
		jno метка/регистр/[адрес_в_памяти]
	Команда JS: выполняет переход к метке, если SF == 1
		js метка/регистр/[адрес_в_памяти]
	Команда JNS: выполняет переход к метке, если SF == 0
		jns метка/регистр/[адрес_в_памяти]
	Команда JZ: выполняет переход к метке, если ZF == 1
		jz метка/регистр/[адрес_в_памяти]
	Команда JNZ: выполняет переход к метке, если ZF == 0
		jnz метка/регистр/[адрес_в_памяти]
		
Управление флагами:
	Команда CLC: сбрасывает в 0 флаг переноса (CF)
		clc		;CF:= 0
	Команда SETC: устанавливает флаг переноса (CF)
		setc	;CF:= 1
	Команда LAHF: копирует флаги состояния из регистра eflags в регистр ah
		lahf	;AH:= EFLAGS
	Команда SAHF: сохраняет флаги состояния из регистра ah в регистр eflags
		sahf	;EfLAGS:= AH
		
Инструкции lahf и sahf применяют следующий порядок битов для флагов, начиная с младшего бита:
	0:=	Флаг переноса (CF)
	1:=Всегда равен 1 (не используется)
	2:=Флаг паритетности (PF)
	3:=Всегда равен 0 (не используется)
	4:=Дополнительный флаг переноса (AF)
	5:=Всегда равен 0 (не используется)
	6:=Флаг нуля (ZF)
	7:=Флаг знака (SF)
___________
Сравнение. Инструкция CMP

Команда CMP сравнивает значения и установливает флаги
	cmp операнд_1, операнд_2	;Флаг нуля ZF устанавливается, если операнд_1 = операнд_2
								;Флаг переноса CF устанавливается, если при вычитании из младшей части 1 операнда(16 бит) - младшей части 2 операнда(16 бит) потребуется заимствование
								;Флаг переполнения OF устанавливается, если при вычитании произойдет переполнение знакового бита.
								;Флаг знака SF устанавливается, если результат отрицательный. При этом установка флага НЕ означает, что 1 операнд обязательно меньше 2 операнда.
	Ограничения:
		Оба операнда должны представлять целые числа
		
Инструкции перехода
	Команда JE: выполняет переход к метке, если ZF == 1 и оба операнда CMP равны
		je метка/регистр/[адрес_в_памяти]
	Команда JNE: выполняет переход к метке, если ZF == 0 и оба операнда CMP НЕ равны
		jne метка/регистр/[адрес_в_памяти]
	Команды JA / JNBE: выполняет переход к метке, если СF == 0 и ZF == 0 и первый операнд CMP больше второго
		ja/jnbe метка/регистр/[адрес_в_памяти]
		Ограничения:
		Оба операнда CMP беззнаковые
	Команды JAE / JNB: выполняет переход к метке, если СF == 0 и первый операнд CMP больше или равен второму
		jae/jnb метка/регистр/[адрес_в_памяти]
		Ограничения:
		Оба операнда CMP беззнаковые
	Команды JB /JNAE: выполняет переход к метке, если СF == 1 и первый операнд CMP меньше второго
		jb/jnae метка/регистр/[адрес_в_памяти]
		Ограничения:
		Оба операнда CMP беззнаковые
	Команды JBE / JNA: выполняет переход к метке, если СF == 1 или ZF == 1 и первый операнд CMP меньше или равен второму
		jbe/jna метка/регистр/[адрес_в_памяти]
		Ограничения:
		Оба операнда CMP беззнаковые
	Команды JG / JNLE: выполняет переход к метке, если SF == OF и ZF == 0 и первый операнд CMP больше второго
		jg/jnle метка/регистр/[адрес_в_памяти]
		Ограничения:
		Оба операнда CMP со знаком
	Команды JGE / JNL: выполняет переход к метке, если SF == OF и первый операнд CMP больше или равен второму
		jge/jnl метка/регистр/[адрес_в_памяти]
		Ограничения:
		Оба операнда CMP со знаком
	Команды JL / JNGE: выполняет переход к метке, если SF != OF и первый операнд CMP меньше второго
		jl/jnge метка/регистр/[адрес_в_памяти]
		Ограничения:
		Оба операнда CMP со знаком
	Команды JLE / JNG: выполняет переход к метке, если SF != OF или ZF == 1 и первый операнд CMP меньше или равен второму
		jle/jng метка/регистр/[адрес_в_памяти]
		Ограничения:
		Оба операнда CMP со знаком
___________
Инструкции условного копирования

Инструкции для сравнения беззнаковых чисел:
	Команда CMOVA: копирует значение, если первый операнд CMP больше второго (CF == 0, ZF == 0)
		cmova destination, source ;destination:= source
	Команда CMOVNBE: копирует значение, если первый операнд CMP не меньше и не равен второму (CF == 0, ZF === 0)
		cmovnbe destination, source ;destination:= source
	Команды CMOVAE / CMOVNC / CMOVNB: копирует значение, если первый операнд CMP больше или равен второму (CF == 0)
		cmovae/cmovnc/cmovnb destination, source ;destination:= source
	Команды CMOVNB / CMOVNC / CMOVAE: копирует значение, если первый операнд CMP не меньше второго (CF == 0)
		cmovnb/cmovnc/cmovae destination, source ;destination:= source
	Команды CMOVB / CMOVC / CMOVNAE: копирует значение, если первый операнд CMP меньше второго (CF == 1)
		cmovb/cmovc/cmovnae destination, source ;destination:= source
	Команды CMOVNAE / CMOVC / CMOVB: копирует значение, если первый операнд CMP не больше и не равен второму (CF == 1)
		cmovnae/cmovc/cmovb destination, source ;destination:= source
	Команда CMOVBE: копирует значение, если первый операнд CMP меньше или равен второму (CF == 1 или ZF == 1)
		cmovbe destination, source ;destination:= source
	Команда CMOVNA: копирует значение, если первый операнд CMP не больше второго (CF == 1 или ZF == 1)
		cmovna destination, source ;destination:= source

Инструкции для сравнения чисел со знаком:
	Команда CMOVG: копирует значение, если первый операнд больше второго (SF == OF или ZF == 0)
		cmovg destination, source ;destination:= source
	Команда CMOVNLE: копирует значение, если первый операнд не меньше и не равен второму (SF == OF или ZF == 0)
		cmovnle destination, source ;destination:= source
	Команда CMOVGE: копирует значение, если первый операнд больше или равен второму (SF == OF)
		cmovge destination, source ;destination:= source
	Команда CMOVNL: копирует значение, если первый операнд не меньше второго (SF == OF)
		cmovnl destination, source ;destination:= source
	Команда CMOVL: копирует значение, если первый операнд меньше второго (SF != OF)
		cmovl destination, source ;destination:= source
	Команда CMOVNGE: копирует значение, если первый операнд не больше и не равен второму (SF != OF)
		cmovnge destination, source ;destination:= source
	Команда CMOVLE: копирует значение, если первый операнд меньше или равен второму (SF != OF или ZF == 1)
		cmovle destination, source ;destination:= source
	Команда CMOVNG: копирует значение, если первый операнд не больше второго (SF != OF или ZF == 1)
		cmovng destination, source ;destination:= source
		
Общие инструкции (для чисел со знаком и для беззнаковых чисел):
	Команда CMOVE: копирует значение, если первый операнд равен второму (ZF=1). 
		cmove destination, source ;destination:= source
	Команда CMOVNE: копирует значение, если первый операнд не равен второму (ZF=0). 
		cmovne destination, source ;destination:= source
___________
Инструкция цикла loop и jrcxz

Инструкции цикла:
	Команда LOOP: уменьшает на 1 число в регистре RCX и переходит к определенной метке, если RCX не равен нулю
		loop адрес_перехода 	;RCX:=RCX - 1
	Команда LOOPE: уменьшает на 1 число в регистре RCX и переходит к определенной метке, если установлен флаг нуля (ZF == 1)
		loope адрес_перехода 	;RCX:=RCX - 1
	Команда LOOPNE: уменьшает на 1 число в регистре RCX и переходит к определенной метке, если флаг нуля не установлен (ZF == 0)
		loopne адрес_перехода 	;RCX:=RCX - 1
	Команда JRCXZ переходит к определенной метке, если RCX == 0
		jrcxz адрес_перехода 
___________
Умножение. Инструкции mul и imul

Команда MUL: Выполняет умножение Accumulator на операнд		;Устарела
	mul r/m8 	;Результат в AX (AX:=AL * r/m8)
	mul r/m16 	;Старшие байты результата в DX, младшие в AX (DX:AX:=AL * r/m16)
	mul r/m32 	;Старшие байты результата в EDX, младшие в EAX (EDX:EAX:=EAX * r/m32)
	mul r/m64 	;Старшие байты результата в RDX, младшие в RAX (RDX:RAX:=RAX * r/m64)
				;Если результат по количеству бит больше разрядности операндов, устанавливает флаг переноса CF и флаг переполнения OF
	Ограничения:
		Операнд беззнаковый
	
Команда IMUL: Выполняет умножение
	imul r/m(8-64) 							;Тоже самое как и в MUL
	imul r(16-64), r/m(16-64) 				;Сохраняет результат в первый операнд, перезаписывая его
	imul r(16-64), r/m(16-64), imm(8-32) 	;Сохраняет результат в первый операнд (r(16-64):=r/m(16-64) * imm(8-32))
	imul r16, r/m16, imm16 					;Сохраняет результат в первый операнд (r16:=r/m16 * imm16)
	imul r32, r/m32, imm32 					;Сохраняет результат в первый операнд (r32:=r/m32 * imm32)
	imul r64, r/m64, imm32 					;Сохраняет результат в первый операнд (r64:=r/m64 * imm32)
___________
Деление. Инструкции div и idiv

;Перед выполнением DIV необходимо убедиться что делимое находиться в Data:Accumulator правильно
	Разделить 8-битное значение без знака на другое:
		Загрузить числитель в регистр AL, а затем переместить 0 в регистр AH
	Разделить 16-битное значение без знака на другое:
		Загрузить 0 в регистр DX
	Разделить 32-битное значение без знака на другое:
		Загрузить 0 в регистр EDX
	Разделить 64-битное значение без знака на другое:
		Загрузить 0 в регистр RDX

Команда DIV: Выполняет деление Data:Accumulator на операнд
	div r/m8 	;Частное в AL, остаток(по модулю) в AH  (:=AX * r/m8)
	div r/m16 	;Частное в AX, остаток в DX (:= DX:AX * r/m16)
	div r/m32 	;Частное в EAX, а остаток в EDX (EDX:EAX * r/m32)
	div r/m64 	;Частное в RAX, а остаток в RDX (RDX:RAX * r/m64)
	Ограничения:
		Операнд беззнаковый

;Перед выполнением IDIV необходимо убедиться что делимое находиться в Data:Accumulator правильно
	Разделить 8-битное знаковое значение на другое:
		Выполнить cbw
	Разделить 16-битное знаковое значение на другое:
		Выполнить cwd
	Разделить 32-битное знаковое значение на другое:
		Выполнить cdq
	Разделить 64-битное знаковое значение на другое:
		Выполнить cqo
		
Инструкции преобразования:
	Команда CBW: преобразует байт в AL в слово в AX через расширение знаком
		cbw		;AX:=FF(AL)
	Команда CWD: преобразует 16-разрядное число в AX в 32-разрядное в DX:AX через расширение знаком
		cwd		;DX:AX:=FFFF:AX
	Команда CDQ: преобразует 32-разрядное число в EAX в 64-разрядное в EDX:EAX с помощью расширения знаком
		cdq		;EDX:EAX:=FFFFFFFF:EAX
	Команда CQO: преобразует 64-разрядное число в RAX в 128-разрядное в RDX:RAX через расширение знаком
		cqo		;RDX:RAX:=FFFFFFFFFFFFFFFF:EAX
	Команда CWDE: преобразует 16-разрядное число в AX в 32-разрядное в EAX с помощью расширения знаком
		cwde	;EAX:=FFFF(AX)
	Команда CDQE: преобразует 32-разрядное число в EAX в 64-разрядное в RAX с помощью расширения знаком
		cdqe	;RAX:=FFFFFFFF(EAX)
		
Команда IDIV: Выполняет деление Data:Accumulator на операнд
	idiv r/m8 	;Частное в AL, остаток(по модулю) в AH  (:=AX * r/m8)
	idiv r/m16 	;Частное в AX, остаток в DX (:= DX:AX * r/m16)
	idiv r/m32 	;Частное в EAX, а остаток в EDX (EDX:EAX * r/m32)
	idiv r/m64 	;Частное в RAX, а остаток в RDX (RDX:RAX * r/m64)
___________
Логические операции

Логические операции:
	Команда AND: выполняет поразрядное логическое умножение, записывая результат в 1 операнд
		and source, dest
	Команда TEST: выполняет поразрядное логическое умножение, изменяя флаги, не записывая результат
		test source, dest
	Команда OR: выполняет поразрядное логическое сложение, записывая результат в 1 операнд
		or source, dest
	Команда XOR: выполняет поразрядную операцию исключающего ИЛИ, записывая результат в 1 операнд
		xor source, dest
	Команда NEG: выполняет поразрядное отрицание, записывая результат в операнд
		neg dest
	Команда NOT: выполняет арифметическое отрицацие(* -1), записывая результат в операнд
		not dest
___________
Сдвиг и вращение

Инструкции сдвига:
	Команда SHL: сдвигает биты dest влево на count
		shl dest, count		;При сдвиге последний отбрасываемый байт копируется в флаг переноса CF (Также меняет ZF, SF, OF)
	Команда SHR: сдвигает биты dest вправо на count
		shr dest, count		;При сдвиге последний отбрасываемый байт копируется в флаг переноса CF (Также меняет ZF, SF = 0, OF)
	Команда SAR: сдвигает биты dest вправо на count, сдвигаемое число влево дополняется не нулями, а значением из старшего бита
		sar dest, count		;При сдвиге последний отбрасываемый байт копируется в флаг переноса CF (Также меняет ZF, SF, OF = 0)
	Команда ROL: сдвигает биты dest влево на count, заполняя пустой разряд отброшенным числом
		rol dest, count		;Последний сдвинутый бит копируется во флаг переноса CF (Также меняет OF = XOR двух старших битов)
	Команда ROR: сдвигает биты dest вправо на count, заполняя пустой разряд отброшенным числом
		ror dest, count		;Последний сдвинутый бит копируется во флаг переноса CF(Также меняет OF = XOR двух старших битов после поворота)
	Команда RCL: сдвигает биты dest влево на count, заполняя пустой разряд значением CF, заполняя CF отброшенным битом
		rcl dest, count
	Команда RCR: сдвигает биты dest вправо на count, заполняя пустой разряд значением CF, заполняя CF отброшенным битом
		rcr dest, count
__________________________________________________
3. Работа с данными и памятью

Определение переменных и типы данных. Секция .data

;Секция данных задается с помощью директивы .data (Инициализация переменных)
;Секция .rodata содержит данные, которые нельзя изменить (Инициализация констант)
;При определении объектов в секции .text получиться константа (Выполнение кода)
;Секция .bss содержит неинициализированные данные, для которых известен размер, но неизвестно значение (используя директивы RESB/RESW/RESD/RESQ)

Типы данных:
byte: 8-разрядное целое число 							;db (define byte)
word: 16-разрядное целое число или слово				;dw (define word)
dword: 32-разрядное целое число или двойное слово		;dd (define dword)
qword: 64-разрядное целое число или четверное слово		;dq (define qword/quad)

Определение данных в программе:
	название_переменной тип_данных значение							
	название_массива тип_данных значение1, значение2, значениеN	
	название_массива times количество_элементов тип_данных значение		;Для создания массива из элементов с одним значением

;Сама переменная хранит адрес в памяти, а [название_переменной] - значение
;При обращении к массиву по имени массива - обращение происходит к первому элементу

Ключевое слово REL: используется для указания адресации относительно указателя инструкций (Делает код более гибким и безопасным)
	[rel some_symbol]	;Программа будет вычислять смещение от текущего значения RIP(указатель адреса следующей инструкции)

Директивы resX: определяет наборы большего размера (По умолчанию каждое такое число будет инициализировано нулем)
	Директива RESB: выделяет некоторое количество байт
		название_переменной resb количество_чисел	;Определяет переменную - набор из N байт
	Директива RESW: выделяет некоторое количество слов (2-х байтовых чисел)
		название_переменной resw количество_чисел	;Определяет набор из N слов
	Директива RESD: выделяет некоторое количество двойных слов (4-х байтовых чисел)
		название_переменной resd количество_чисел	;Определяет набор из N двойных слов
	Директива RESQ: выделяет некоторое количество четверных слов (8-х байтовых чисел)
		название_переменной resq количество_чисел	;Определяет набор из N четверных слов

Операторы преобразований:
BYTE: преобразует в байт
	byte [название_переменной]		;Переменная станет byte
WORD: преобразует в слово
	word [название_переменной]		;Переменная станет word
DWORD: преобразует в двойное слов
	dword [название_переменной]		;Переменная станет dword
QWORD: преобразует в четверное слово
	qword [название_переменной]		;Переменная станет qword
___________
Косвенная адресация

Адресация в NASM
Обращение по некоторому адресу в NASM задается следующей формулой:
[base + (index * scale) + offset]
Основные компоненты формулы:
	base: базовый регистр, который содержит некоторый адрес. Это r(32-64) регистр общего назначения или регистр RSP
	index: индексный регистр, который содержит некоторый индекс относительно адреса в базовом регистре. В качестве индексного регистра также могут r(32-64) регистр общего назначения или регистр RSP
	scale: множитель, на который умножается значение индексного регистра. Может принимать значения 1, 2, 4 или 8
	offset: может представлять 32-разрядное значение в виде числа или имени переменной. Это может быть r64 регистр общего назначения или регистр RSP

;Необязательно использовать сразу все компоненты для определения адреса
	[base]								;Только базовый регистр
	[offset]							;Числовое смещение (абсолютный адрес) или переменная (адрес значения переменной)
	[base + offset]						;Базовый регистр + смещение
	[base + index]						;Базовый регистр + индексный регистр
	[index * scale]						;Индексный регистр, умноженный на мультиприкатор
	[index * scale + offset]			;Индексный регистр, умноженный на мультиприкатор, + смещение
	[base + index * scale]				;Базовый регистр + индексный регистр, умноженный на мультиприкатор
	[base + index * scale + offset]		;Базовый регистр + индексный регистр, умноженный на мультиприкатор, + смещение

Команда LEA: записывает в регистр адрес
		lea r64_хранящий_адрес, адрес	;r64:= адрес
___________
Получение текущего адреса

Оператор $: Возвращает текущий адрес операнда
	название_переменной dq $	;Переменная хранит свой собственный адрес
	
;Вычитая из адреса размер операнда, получиться адрес предыдущего операнда

;Работа с массивами:
	название_переменной equ $ - arr    								;Хранит размер массива arr
	название_переменной equ ($ - arr) / размер_элементов_массива	;Хранит количество элементов массива arr
___________
Константы

Директива EQU: позволяет определить константы, которые будут заменяться ассемблером на их значения при компиляции программы
	название_константы equ значение_константы	;При компиляции заменит константу на значение
	
;Выражения, которые возвращают значение констант, могут применять стандартные арифметические операции(сложение/вычитание/умножение), где операндами могут быть и другие константы
___________
Символы

;Каждому символу соответствует определенный числовой код (8 разрядный) из таблицы ASCII
;В ASCII строчные буквы отличаются от заглавных установленным 6-м битом
	Для перехода от строчной буквы к заглавной и обратно: 
		Вычесть 32 / прибавить 32
		and операнд, 0xDF / or операнд, 0x20 
		
;В ASCII для перехода от числа к его символьному представлению и обратно необходимо 
	Прибавить 48 / вычесть 48
	and операнд, 0xF / or операнд, 0x30 
;Символ записывается в '' или ""
;При записи символа будет храниться его числовой код
___________
Строки

;Строка - массив символов

section .data 
    chars1 db 72, 101, 108, 108, 111     ; строка "Hello"
	chars2 db "H", "e", "l", "l", "o"
	chars3 db "Hello"

;Для сочетания печатных и непечатных символов используется запятая
section .data
chars db "Hello world!", 10		;Hello world! перевод на новую строку (числовой код - 10)
	
;В зависимости от ОС системные вызовы для вывода строки отличаются
___________
Порядок байтов. Big-endian и little-endian

;При работе с данными следует учитывать порядок байтов
	Порядок big-endian предполагает расположение байтов от старшего к младшему
	Порядок little-endian предполагает расположение байтов от младшего к старшему
	
Число 0x01234567 в big-endian:		;При обращении к byte [число] получим 01(1й байт)
Адрес		0x0000	0x0001	0x0002	0x0003
Значение	01	    23	    45	    67

Число 0x01234567 в little-endian:	;При обращении к byte [число] получим 67(1й байт)
Адрес		0x0000	0x0001	0x0002	0x0003
Значение	67	    45	    23	    01

;Архитектура Intel x86-64 для расположения байтов применяет порядок little-endian
___________
Структуры

;Структуры позволяют объединить разрозненные данные в единое целое и манипулировать этими данными как единым объектом
;Ядро ассемблера NASM не содержит встроенных средств определения структур (можно только их эмулировать)

Структура: 
section .data
person:						;Условная структура (представляет набор из трех компонентов - 3 чисел типа .quad)
    dq alice    			;Адрес строки
    dq alice_name_size   	;Размер имени
    dq 34      				;Возраст
 
;Смещение компонентов в структуре
NAME_OFFSET equ 0
NAME_SIZE_OFFSET equ 8
AGE_OFFSET equ 16
 
alice db "Alice", 10  			;Имя
alice_name_size equ $-alice   	;Размер имени

section .text
mov r64, person
	;[r64 + person] = адрес строки (имя)
	;[r64 + NAME_SIZE_OFFSET] = длина строки (имени)
	;[r64 + AGE_OFFSET] = значение числа (возраст)
	
Массив структур
section .data
people:									;Массив структур
 dq alice, alice_name_size, 34			;Название_структуры, размер_имени, возраст
 dq kate, kate_name_size, 25			;Название_структуры, размер_имени, возраст
 dq tom, tom_name_size, 39				;Название_структуры, размер_имени, возраст
count equ ($ - people)/PERSON_SIZE     	;Количество данных в массиве

alice db "Alice",10						;Имя
alice_name_size equ $-alice				;Размер имени alice
kate db "Kate",10						;Имя
kate_name_size equ $-kate				;Размер имени kate
tom db "Tom",10							;Имя
tom_name_size equ $-tom					;Размер имени tom

;Смещение компонентов в структуре
NAME_OFFSET equ 0
NAME_SIZE_OFFSET equ 8
AGE_OFFSET equ 16

PERSON_SIZE equ 24		;Размер одной структуры в байтах
___________
Структуры и макросы STRUC / ENDSTRUC

Для упрощения определения структур и работы с ними NASM предоставляет макросы STRUC и ENDSTRUC. 
	Определение шаблона с помощью STRUC / ENDSTRUC.
	Выделение памяти (создание экземпляра) в секции данных (.data / .bss).
	Доступ к полям экземпляра через базовый адрес + смещение поля.

struc person			; Определение типа структуры
    .id:        resd 1  ; 4 байта ID
    .name:      resb 20 ; 20 байт Имя
    .age:       resw 1  ; 2 байта Возраст
endstruc
 
section .data
    kate:										; Инициализированный экземпляр
        istruc person      						;Начало экземпляра структуры person
            at person.id,       dd 101          ; в поле .id число 101 
            at person.name,     db "Kate", 10   ; в .name строка "Kate", 10
            at person.age,      dw 41           ; в поле .age число 41
        iend                					;Завершение экземпляра структуры person
  
section .text
_start:
	mov r64, [kate + person.id]  		; в r64 - id
    mov r64, kate + person.name    		; в r64 - адрес строки
    mov r64, person.age - person.name  	; в r64 - длина строки
    mov r64, [kate + person.age]  		; в r64 - возраст
    mov rax, 60
    syscall
___________
Стек

;Стек — это динамическая структура данных, хранящая важную информация о программе, включая локальные переменные, информацию о подпрограммах и временные данные
;Алгоритм LIFO - последний вошел, первый вышел
;Процессор x86-64 управляет стеком через специальный регистр RSP (указатель стека)


Команда PUSH: записывает в стек значение
	push r(16/64)/m(16/64)/imm(16/32)	;Запишет значение в стек (32-битная констранта расширяется до 64 бит)
										;rsp = rsp - размер операнда
										;[rsp] = значение операнда

Команда POP: забирает значение из стека
	pop r(16/64)/m(16/64)	;Запишет значение в операнд 
							;operand = [rsp]
							;rsp = rsp + размер операнда

Команда PUSHFQ: сохраняет значения флагов состояния
	pushfq		;Сохранит значение RFLAGS

Команда POPFQ: восстанавливает значения флагов состояния
	popfq		;Восстановит значение RFLAGS
	
;Для восстановления стека без извлечения данных, необходимо добавить к RSP N байт смещения

Косвенная адресация:
	sub rsp, 16  		;Резервация в стеке 16 байт
    mov rdx, 11			;Число 11 занимает 16 байт
    mov [rsp], rdx		;Запись в стек значение регистра RDX
    mov rdi, [rsp]		;Получение значение по адресу из RSP (Из стека)
    add rsp, 16 		;Восстанавление значения стека

Для получения предыдущих значений из стека применяется смещение и масштабирование
	[rsp+размер_значений_на_которые_необходимо_сместиться]
___________
Копирование и сохранение в строку

;Строки представляют набор значений-байтов, который хранится в непрерывной области памяти

Процессор x86-64 поддерживает работу с 4 типами строк:
	Строки значений byte
	Строки из чисел word
	Строки из двойных слов dword
	Строки из четверных слов qword

Строковые инструкции используют определенные регистры в качестве операндов:
	RSI: хранит индекс значений исходной строки
	RDI: хранит индекс значений целевой строки
	RCX: счетчик значений
	AL, AX, EAX и RAX
	Флаги в регистре RFLAGS

Для копирования строк применяются следующие инструкции:
Команда MOVSB: 	извлекает байт по адресу RSI
				сохраняет его по адресу RDI, 
				увеличивает/уменьшает регистры RSI и RDI на 1 
				повторяет RCX раз
	movsb
Команда MOVSW: 	извлекает слово по адресу RSI, 
				сохраняет его по адресу RDI, 
				увеличивает/уменьшает RSI и RDI на 2 
				повторяет RCX раз
	movsw
Команда MOVSD: 	извлекает двойное слово по адресу RSI, 
				сохраняет его по адресу RDI, 
				увеличивает/уменьшает адрес в регистрах RSI и RDI на 4 
				повторяет RCX раз
	movsd
Команда MOVSQ: 	извлекает четверное слово по адресу RSI, 
				сохраняет его по адресу RDI, 
				увеличивает/уменьшает адрес в регистрах RSI и RDI на 8 
				повторяет RCX раз
	movsq
	
	
section .data
nums dw 10, 11, 12, 13, 14, 15, 16, 17
 
section .bss
copy resw 8  				; 8 чисел по 2 байта равных 0
 
section .text
_start:
    mov rsi, nums           ;RSI - откуда копировать
    mov rdi, copy           ;RDI - куда копировать
    mov rcx, 8             	;RCX - сколько копировать
    rep movsw               ;Выполняется копирование по отдельным словам

Префикс rep: указывает процессору повторить эту операцию столько раз, сколько указано в регистре RCX
	rep movsb/movsw/movsd/movsq

section .data
nums dw 10, 11, 12, 13, 14, 15, 16, 17
 
section .bss
copy resw 8  				; 8 чисел по 2 байта равных 0
 
section .text
_start:
    mov rsi, nums           ;RSI - откуда копировать
    mov rdi, copy           ;RDI - куда копировать
    mov rcx, 2              ;RCX - сколько копировать (8 слов - это два четверных слова qword)
    rep movsq               ;Выполняется копирование по четверному слову qword

Если количество байт не кратно 8/нечетное, то для большей эффективности можно комбинировать копирование различных данных:
	rep movsq       ;Выполняется копирование по четверному слову qword (8)
        movsw       ;Выполняется копирование одного слова word	(8 + 1 = 9)
___________
Сравнение строк
___________
Поиск в строке
__________________________________________________
Глава 4. Функции

Определение и вызов функций
___________
Сохранение регистров и переменных при вызове функций
___________
Параметры функции
___________
Результат функции
___________
Фрейм стека и локальные переменные
___________
Локальные метки
___________
Организация программы
__________________________________________________
Глава 5. Системные вызовы

Системные вызовы в Linux и инструкция syscall
___________
Системные вызовы и прерывания
__________________________________________________
Глава 6. Взаимодействие кода ассемблера и C/C++

Вызов функций C/C++ из ассемблера на Linux

Вызов функций C/C++ из ассемблера на Windows

Вызов функции ассемблера из C/C++

Передача структур между ассемблером и C/C++

Работа с файлами
__________________________________________________
Глава 7. SIMD

Числа с плавающей точкой

Расширения SSE и AVX/AVX2

Копирование данных с помощью инструкций SIMD

Преобразование чисел с плавающей точкой в целые числа и обратно

Арифметика чисел с плавающей точкой

Сравнение чисел с плавающей точкой

Операции сдвига SSE/AVX

Логические операции над векторами

Сложение с помощью инструкций SSE/AVX

Вычитание с помощью инструкций SSE/AVX

Умножение с помощью инструкций SSE/AVX

Математические инструкции SSE/AVX

Сравнение целых чисел в SSE/AVX

Арифметические операции с векторами чисел с плавающей точкой

Сохранение состояния регистров SSE/AVX
__________________________________________________
Глава 8. Препроцессор

Директивы препроцессора

Условные конструкции препроцессора

Макросы
__________________________________________________
Глава 9. Разделяемые библиотеки в Linux

Создание разделяемых библиотек для Linux

Код, независимый от позиции

Подключение встроенных библиотек Linux

Переопределение общих библиотек

Программная загрузка библиотек
__________________________________________________
Глава 10. Дополнительные статьи

Стек, аргументы программы и переменные окружения в Linux

Манипуляции с консолью и курсором

Реализация конечных автоматов


























