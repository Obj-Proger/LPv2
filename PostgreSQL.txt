PostgreSQL
__________________________________________________
Определение структуры данных

Создание и удаление базы данных

Для именования объектов в SQL используются:
	snake_сase - стандарт
	camelCase - для согласованности с кодом приложения

--Однострочный комментарий

/*Многострочный комментарий*/

--Создание базы данных
CREATE DATABASE название_базы_данных

--Удаление базы данных
DROP DATABASE название_базы_данных
___________
Создание и удаление таблиц

--Создание таблицы
CREATE TABLE название_таблицы
(название_столбца1 тип_данных атрибуты_столбца1, 
 название_столбца2 тип_данных атрибуты_столбца2,
 название_столбцаN тип_данных атрибуты_столбцаN,
 атрибуты_таблицы
);

--Удаление таблицы
DROP TABLE название_таблицы
___________
Типы данных в PostgreSQL

Числовые типы данных:
	serial: [1 - 2147483647] представляет автоинкрементирующееся числовое значение, которое занимает 4 байта 
	smallserial: [1 - 32767] представляет автоинкрементирующееся числовое значение, которое занимает 2 байта. Аналог типа serial для небольших чисел
	bigserial: [1 - 9223372036854775807] представляет автоинкрементирующееся числовое значение, которое занимает 8 байт. Аналог типа serial для больших чисел
	smallint: [-32768 - +32767] Занимает 2 байта. Имеет псевдоним int2
	integer: [-2147483648 - +2147483647] Занимает 4 байта. Имеет псевдонимы int и int4
	bigint: [-9223372036854775808 - +9223372036854775807] Занимает 8 байт. Имеет псевдоним int8
	numeric: хранит числа с фиксированной точностью, которые могут иметь до 131072 знаков в целой части и до 16383 знаков после запятой
		Данный тип может принимать два параметра precision и scale: numeric(precision, scale).
			Параметр precision указывает на максимальное количество цифр, которые может хранить число
			Параметр scale представляет максимальное количество цифр, которые может содержать число после запятой. Это значение должно находиться в диапазоне от 0 до значения параметра precision. По умолчанию оно равно 0
	decimal: хранит числа с фиксированной точностью, которые могут иметь до 131072 знаков в целой части и до 16383 знаков в дробной части. То же самое, что и numeric
	real: [1E-37 - 1E+37]хранит числа с плавающей точкой. Занимает 4 байта. Имеет псевдоним float4.
	double precision: [1E-307 до 1E+308]хранит числа с плавающей точкой. Занимает 8 байт. Имеет псевдоним float8

Типы для работы с валютой (денежными единицами):
	money: [-92233720368547758.08 - +92233720368547758.07] и занимает 8 байт

Символьные типы:
	character(n): представляет строку из фиксированного количества символов. С помощью параметра задается задается количество символов в строке. Имеет псевдоним char(n)
	character varying(n): представляет строку из переменной длины. С помощью параметра задается задается максимальное количество символов в строке. Имеет псевдоним varchar(n)
	text: представляет текст произвольной длины

Бинарные данные:
	bytea: хранит данные в виде бинарных строк, которые представляют последовательность октетов или байт

Типы для работы с датами и временем
	timestamp: [4713 г до н.э. - 294276 г н.э.]хранит дату и время. Занимает 8 байт
	timestamp with time zone: то же самое, что и timestamp, только добавляет данные о часовом поясе
	date: [4713 г. до н.э. - 5874897 г н.э.] представляет дату. Занимает 4 байта
	time: [00:00:00 до 24:00:00] хранит время с точностью до 1 микросекунды без указания часового пояса. Занимает 8 байт
	time with time zone: [00:00:00+1459 до 24:00:00-1459]хранит время с точностью до 1 микросекунды с указанием часового пояса. Занимает 12 байт
	interval: представляет временной интервал. Занимает 16 байт

Распространенные форматы дат:
	yyyy-mm-dd - 1999-01-08
	Month dd, yyyy - January 8, 1999
	mm/dd/yyyy - 1/8/1999

Распространенные форматы времени:
	hh:mi - 13:21
	hh:mi am/pm - 1:21 pm
	hh:mi:ss - 1:21:34

Логические типы:
	boolean может хранить одно из двух значений: true или false
		Вместо true можно указывать следующие значения: TRUE, 't', 'true', 'y', 'yes', 'on', '1'
		Вместо false можно указывать следующие значения: FALSE, 'f', 'false', 'n', 'no', 'off', '0'

Типы для представления интернет-адресов:
	cidr: (Например, 192.168.0.1.) интернет-адрес в формате IPv4 и IPv6. Занимает от 7 до 19 байт.
	inet: (Например, 192.168.0.1/24 или 2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128) интернет-адрес в формате cidr/y, где cidr это адрес в формате IPv4 или IPv6, а /y - количество бит в адресе (если этот параметр не указан, то используется 34 для IPv4, 128 для IPv6). Занимает от 7 до 19 байт.
	macaddr: хранит MAC-адрес. Занимает 6 байт.
	macaddr8: хранит MAC-адрес в формате EUI-64. Занимает 8 байт.

Геометрические типы:
	point: представляет точку на плоскости в формате (x,y). Занимает 16 байт.
	line: представляет линию неопределенной длины в формате {A,B,C}. Занимает 32 байта.
	lseg: представляет отрезок в формате ((x1,y1),(x2,y2)). Занимает 32 байта.
	box: представляет прямоугольник в формате ((x1,y1),(x2,y2)). Занимает 32 байта.
	path: представляет набор содиненных точек. В формате ((x1,y1),...) путь является закрытым (первая и последняя точка соединяются линией) и фактически представляет многоугольник. В формате [(x1,y1),...] путь является открытым Занимает 16+16n байт.
	polygon: представляет многоугольник в формате ((x1,y1),...). Занимает 40+16n байт.
	circle: представляет окружность в формате <(x,y),r>. Занимает 24 байта.

Остальные типы данных
	json: хранит данные json в текстовом виде.
	jsonb: хранит данные json в бинарном формате.
	uuid: (Например a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11) хранит универсальный уникальный идентификатор (UUID). Занимает 32 байта.
	xml: хранит даные в формате XML.
___________
Ограничения столбцов и таблиц

При определении таблиц и их столбцов в SQL можно использовать ряд атрибутов, которые накладывают определенные ограничения

--PRIMARY KEY (первичный ключ) - уникально идентифицирует строку в таблице
	--Установка при объявлении
	Id SERIAL PRIMARY KEY

        --Установка после объявления(на уровне таблицы)
	Id SERIAL,
	PRIMARY KEY(Id)

--Составной PRIMARY KEY
	r1 INTEGER
	r2 INTEGER
	PRIMARY KEY(r1, r2)

UNIQUE - столбец должен иметь только уникальные значения

NULL и NOT NULL - может ли столбец принимать значение NULL (по умолчанию NULL)

DEFAULT Значение - определяет значение по умолчанию для столбца

CHECK(условие) задает ограничение для диапазона значений, которые могут храниться в столбце
	Для условий:
		AND - логическое И
		OR - логическое ИЛИ
		= - Равно
		!= - Не равно
		>/>= Больше/Больше или равно
		</<= Меньше/Меньше или равно

--Оператор CONSTRAINT - задает имя для ограничений
CONSTRAINT название_ограничения ОГРАНИЧЕНИЕ
___________
Внешние ключи

Для связи между таблицами применяются внешние ключи

--Установка внешнего ключа на уровне столбца:
t1 тип_данных REFERENCES ref_table (row_ref_table)
    [ON DELETE {CASCADE|RESTRICT}] --Уточняет поведение при удалении данных
    [ON UPDATE {CASCADE|RESTRICT}] --Уточняет поведение при обновлении данных

Действия: 
	NO ACTION: действие по умолчанию, предотвращает какие-либо действия в зависимой таблице при удалении или изменении связанных строк в главной таблице. И генерирует ошибку
	CASCADE: автоматически удаляет или изменяет строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице
	RESTRICT: предотвращает какие-либо действия в зависимой таблице при удалении или изменении связанных строк в главной таблице
	SET NULL: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL
	SET DEFAULT: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение по умолчанию, которое задается с помощью атрибуты DEFAULT. Если для столбца не задано значение по умолчанию, то в качестве него применяется значение NULL
___________
Изменение таблиц

Для изменения таблицы используется оператор ALTER TABLE
ALTER TABLE название_таблицы

Действия для изменения таблицы:
	ADD название_столбца тип_данных_столбца [ограничения_столбца] --Добавление нового столбца
 	DROP COLUMN название_столбца --Удаление столбца
 	ALTER COLUMN название_столбца TYPE тип_данных_столбца --Изменение типа столбца
	ALTER COLUMN название_столбца SET [ограничения_столбца] --Добавление ограничения столбца
	ALTER COLUMN название_столбца DROP [ограничения_столбца] --Удаление ограничения столбца
	ADD [CONSTRAINT] определение_ограничения --Добавление ограничения
	DROP [CONSTRAINT] имя_ограничения --Удаление ограничения
	RENAME COLUMN название_столбца TO название_таблицы --Переименование столбца
	RENAME TO название_таблицы --Переименование таблицы
__________________________________________________
Операции с данными

Добавление данных. Команда Insert

--Добавлениие одной записи
INSERT INTO имя_таблицы (столбец1, столбец2, ... столбецN) 
VALUES (значение1, значение2, ... значениеN)

--Добавление нескольких записей
INSERT INTO имя_таблицы (столбец1, столбец2, ... столбецN) 
VALUES (значение1, значение2, ... значениеN),
	(значение1, значение2, ... значениеN),
	(значение1, значение2, ... значениеN);

___________
Получение данных. Команда Select

--Получение одного столбца
SELECT название_столбца FROM имя_таблицы


--Получение нескольких столбцов
SELECT название_столбца1, название_столбцаN FROM имя_таблицы

--Получение всех столбцов
SELECT * FROM имя_таблицы

--Получение результата арифметической операции столбцов
SELECT название_столбца1 +-*/% название_столбца2 FROM имя_таблицы

--Определение псевдонима для столбца (Оператор AS)
SELECT название_столбцаN AS N FROM имя_таблицы
___________
Фильтрация. WHERE

--Для фильтрации данных применяется оператор WHERE
WHERE условие

Операции сравнения:
	=: сравнение на равенство
	<>: сравнение на неравенство
	!=: сравнение на неравенство
	<: меньше чем
	>: больше чем
	<=: меньше чем или равно
	>=: больше чем или равно

Логические операторы:
	AND: операция логического И
	OR: операция логического ИЛИ
	NOT: операция логического отрицания
	IS NULL: проверка на NULL
	IS NOT NULL: проверка на NOT NULL
___________
Обновление данных. Команда UPDATE

--Для обновления данных применяется команда UPDATE
UPDATE имя_таблицы
SET столбец1 = значение1, столбец2 = значение2, ... столбецN = значениеN
[WHERE условие_обновления]
___________
Удаление данных. Команда DELETE

--Для удаления данных применяется команда DELETE
DELETE FROM имя_таблицы
[WHERE условие_удаления]

--Удаление всех строк ОПАСНО!
DELETE FROM имя_таблицы
__________________________________________________
Запросы

DISTINCT. Выборка уникальных значений

--DISTINCT позволяет выбрать уникальные данные по определенным столбцам
SELECT DISTINCT название_столбца FROM имя_таблицы;
___________
ORDER BY. Сортировка

--ORDER BY позволяет отсортировать значения по определенному столбцу
SELECT * FROM имя_таблицы
ORDER BY название_столбца;

--Сортировка по псевдониму
SELECT столбец_N AS N FROM имя_таблицы
ORDER BY N;

--Сортировка по выражению
SELECT * FROM имя_таблицы
ORDER BY столбец1 +-*/% столбец2;

--Сортировка по убыванию (по умолчанию стоит ASC = по возрастанию)
SELECT * FROM имя_таблицы
ORDER BY название_столбца DESC;

--Сортировка по нескольким столбцам
SELECT * FROM имя_таблицы
ORDER BY название_столбца1, название_столбца2;

--Сортировка по нескольким столбцам (с разными порядками)
SELECT * FROM имя_таблицы
ORDER BY название_столбца1 ASC, название_столбца2 DESC;
___________
Получение диапазона строк. LIMIT и OFFSET

--LIMIT позволяет извлечь определенное количество строк
SELECT * FROM имя_таблицы
ORDER BY название_столбца
LIMIT N;

--OFFSET позволяет указать, с какой строки надо начинать выборку
SELECT * FROM имя_таблицы
ORDER BY название_столбца
OFFSET M;

--Диапазон строк
SELECT * FROM имя_таблицы
ORDER BY название_столбца
LIMIT N OFFSET M;
___________
Операторы фильтрации

--IN позволяет определить набор значений, которые должны иметь столбцы
WHERE выражение [NOT] IN (набор_значений)

--BETWEEN определяет диапазон значений с помощью начального и конечного значения, которому должно соответствовать выражение
WHERE выражение [NOT] BETWEEN начальное_значение AND конечное_значение

--LIKE принимает шаблон строки, которому должно соответствовать выражение
WHERE выражение [NOT] LIKE шаблон_строки

--ILIKE работает как LIKE но не регистрозависим

Шаблоны строки:
	 %: соответствует любой подстроке, которая может иметь любое количество символов, при этом подстрока может и не содержать ни одного символа
	_: соответствует любому одиночному символу

___________
Агрегатные функции

AVG: находит среднее значение. 

BIT_AND: выполняет операцию побитового умножения (операции логического И)
	Если параметр содержит значение NULL, то возвращается NULL.

BIT_OR: выполняет операцию побитового сложения (операции логического ИЛИ) 
	Если параметр содержит значение NULL, то возвращается NULL.

BOOL_AND: выполняет операцию логического умножения для значений типа bool. 
	Если входные все значения равны true, то возвращается true, иначе возвращается false.

BOOL_OR: выполняет операцию логического сложения для значений типа bool. 
	Если входные хотя бы одно из значений равно true, то возвращается true, иначе возвращается false.

COUNT(*): находит количество строк в запросе

COUNT(expression): находит количество строк в запросе, для которых expression не содержит значение NULL.

SUM: находит сумму значений

MIN: находит наименьшее значение

MAX: находит наибольшее значение

STRING_AGG(expression, delimiter): соединяет с помощью delimiter все текстовые значения из expression в одну строку.
___________
Группировка

--GROUP BY и HAVING: применяются для группировки данных
SELECT столбцы
FROM таблица
[WHERE условие_фильтрации_строк]
[GROUP BY столбцы_для_группировки]
[HAVING условие_фильтрации_групп]
[ORDER BY столбцы_для_сортировки]

--GROUPING SETS: позволяет по отдельности сгруппировать получемые наборы, выбранные предложениями FROM и WHERE
SELECT столбец1, столбец2, aggregate(столбец3)
FROM название_таблицы
GROUP BY GROUPING SETS(столбец1, столбец3); 
--Создаст две группы: 
	столбец1 и столбец2 
	столбец2 и столбец3

--ROLLUP: добавляет суммирующую сводку в результирующий набор 
SELECT столбец1 и столбец2, aggregate(столбец3)
FROM название_таблицы
GROUP BY ROLLUP(столбец1 и столбец2); 
--Создаст строки: 
	Сумма(aggregate) по строкам: столбец1 
	Сумма(aggregate) по строкам: столбец2

--При группировке по нескольким критериям ROLLUP будет создавать суммирующую строку для каждой из подгрупп

--CUBE: используется для одновременного создания нескольких группирующих наборов
SELECT столбец1 и столбец2, aggregate(столбец3)
FROM название_таблицы
GROUP BY CUBE(столбец1 и столбец2); 
--Создаст строки: 
	Общая сводка по столбец3
	Сумма(aggregate) по строкам: столбец1 и столбец2
	Сумма(aggregate) по строкам: столбец1 
	Сумма(aggregate) по строкам: столбец2 
___________
Подзапросы

Подзапросы - запросы SELECT, которые вложены в другой SQL-оператор (основной запрос) и используются для получения данных, применяемых в качестве условия, фильтра или для подстановки значений.

Типы подзапросов
	Скалярный подзапрос: Возвращает ровно одну строку и один столбец. Используется в выражениях сравнения 
	Табличный подзапрос: Возвращает множество строк и столбцов. Используется с операторами для работы с несколькими значениями, такими как IN, NOT IN, EXISTS, ALL, ANY. 
	Коррелирующий подзапрос: Ссылается на столбец из внешнего (основного) запроса. Выполняется повторно для каждой строки основного запроса

--Чтобы избежать двойственности при фильтрации в подзапросе используются разные псевдонимы для строки основного запроса и подзапроса
__________________________________________________
Составные типы данных

Массивы

--Создание массива
название_столбца тип_данных[]

--Добавление записей
VALUES('{значение1, значение2, значениеN}')

--Извлечение данных(весь массив)
SELECT название_столбца FROM название_таблицы

--Извлечение данных(диапазон)
SELECT название_столбца[N:M] FROM название_таблицы; --N: индекс начала диапазона, M: индекс конца диапазона

--Обновление данных
SET название_столбца = '{значение1, значение2, значениеN}'; --Перезапись массива
SET название_столбца[N] = 'значениеN' --Обновление элемента;
___________
Перечисления enum

enum: специальный тип данных, который представляет набор констант

--Создание перечисления
CREATE TYPE название_перечисления AS enum('значение1', 'значение2', 'значениеN');

--После создания перечисления можно использовать его в качестве типа столбца.
--Столбец может иметь только одно из указанных значений, которые регистрозависимы

--Добавление нового значения в перечисление
ALTER TYPE название_перечисления ADD VALUE 'значение';

--Удалить уже имеющееся значение из перечисления нельзя
--Можно создать новое перечисление и указать, чтобы таблица использовала его
ALTER TABLE название_таблицы ALTER COLUMN название_столбца TYPE название_перечисления2
USING название_столбца::text::название_перечисления2;

--Удаление перечисления
DROP TYPE название_перечисления;
__________________________________________________
Соединение таблиц

Неявное соединение таблиц

--Прямое(декартово) произведение двух групп (N*M)
SELECT * FROM таблица1, таблица2;

--Соединение таблиц через WHERE
SELECT *
FROM таблица_1 AS т1, таблица_2 AS т2, таблица_3 AS т3 
WHERE т2.внешний_ключ_т1 = т1.Id
AND т2.внешний_ключ_т3 = т3.Id;
___________
INNER JOIN

--Соединение таблиц через JOIN(INNER JOIN)
SELECT *
FROM таблица_2 AS т2
JOIN таблица_1 AS т1 ON т2.внешний_ключ_т1 = т1.Id
JOIN таблица_3 AS т3 ON т2.внешний_ключ_т3 = т3.Id;

--INNER JOIN(Внутреннее соединение):
SELECT столбцы
FROM таблица1
    [INNER] JOIN таблица2 ON условие1
    [[INNER] JOIN таблица3 ON условие2]
___________
OUTER JOIN и CROSS JOIN

--OUTER JOIN(Внешнее соединение): позволяет возвратить все строки одной или нескольких таблиц, которые участвуют в соединении
SELECT столбцы
FROM таблица1
    {LEFT|RIGHT|FULL} [OUTER] JOIN таблица2 ON условие1;
    
Ключевые слова перед OUTER JOIN (OUTER - необязательно)
	LEFT: выборка будет содержать все строки из первой или левой таблицы
	RIGHT: выборка будет содержать все строки из второй или правой таблицы
	FULL: выборка будет содержать все строки из обеих таблиц

--CROSS JOIN: Декартово произведение (N*M)
SELECT * FROM таблица1 CROSS JOIN таблица2;
SELECT * FROM таблица1, таблица2; --Неявное
___________
Группировка в соединениях

SELECT *
FROM таблица1
JOIN таблица_1 AS т1 ON т2.внешний_ключ_т1 = т1.Id
GROUP BY т1.Id, т1.столбец;
___________
Объединение множеств. UNION

--UNION: позволяет объединить два множества
SELECT_выражение1
UNION [ALL] SELECT_выражение2
[UNION [ALL] SELECT_выражениеN]

--При объединении, количество выбираемых столбцов и их тип совпадают для обеих выборок

--Если оба объединяемых набора содержат в строках идентичные значения, то при объединении повторяющиеся строки удаляются

--Если же необходимо при объединении сохранить все, в том числе повторяющиеся строки, то для этого необходимо использовать оператор ALL:
SELECT_выражение1
UNION ALL SELECT_выражение2

--В выражениях ORDER BY необходимо ориентироваться именно на названия столбцов первой выборки

--Объединение столбцов в строку
SELECT FirstName || ' ' || LastName AS FullName
___________
Разность множеств. EXCEPT

--EXCEPT: позволяет найти разность двух выборок
SELECT_выражение1
EXCEPT SELECT_выражение2

--При нахождении разности, количество выбираемых столбцов и их тип совпадают для обеих выборок
___________
Пересечение множеств. INTERSECT

--INTERSECT: позволяет найти общие строки для двух выборок(выполняет операцию пересечения множеств)
SELECT_выражение1
INTERSECT SELECT_выражение2

--При нахождении пересечения, количество выбираемых столбцов и их тип совпадают для обеих выборок
__________________________________________________
Представления

--Представления: виртуальные таблицы, основанные на сохранённых SQL-запросах
CREATE VIEW название_представления
AS SELECT_выражение;

--Изменение представления(нельзя изменять столбцы, представленные ранее)
CREATE OR REPLACE VIEW название_представления
AS SELECT_выражение;

--При применении INSERT, UPDATE, DELETE к представлению, изменения затронут и основную таблицу

Ограничения автоизменяемых представлений:
	FROM в подзапросе содержит только один элемент
	Элементом является таблица или автоизменяемое представление
	Определение представления не содержит WITH, DISTINT, GROUP BY, HAVING, LIMIT, OFFSET на верхнем уровне подзапроса
	Определение не содержит операций с множествами(UNION, EXCEPT, INTERSECT) на верхнем уровне подзапроса
	Не содержит агрегатных, оконных и возвращающих множества функций

--Удаление представления
DROP VIEW название_представления
___________
Индексы

Индекс - структура данных, позволяющая ускорить выполнение операций поиска

Структура индекса:
	Ключ - поля, по которым будет производиться поиск в таблице
	Структура данных - структура данных для хранения индекса
	Ссылки на строки таблицы - каждый индекс содержит указатели на строки таблицы, соответствующие ключевым значениям

Типы индексов:
	B-tree индекс (=, <, >, BEETWEEN) - Самый частоиспользуемый
	Hash индекс (=) Не рекомендуется, особенно при частом изменении таблиц
	GIN индекс (Массивы, текстовые данные, jsonb)
	GIST индекс (Геометрические данные, координаты, диапазоны)

--Создание индекса
CREATE INDEX название_индекса ON название_таблицы USING код_индекса(названия_столбцов) --Для b-tree необязателен код_индекса

Преимущества:
	Ускорение поиска
	Ускорение сортировки
	Ускорение JOIN

Недостатки:
	Занимают место на диске
	Замедление вставки/обновлений
	Требуют дополнительных ресурсов для поддержки актуальных данных

--Отслеживание плана выполнения запроса(и его стоимости)
EXPLAIN Запрос;

pg_stat_user_indexes: Системная таблица, хранящая в себе информацию про использование индексов

--Перестроение индекса
REINDEX INDEX название_индекса;

--Перестроение индексов связанных с таблицей
REINDEX TABLE название_таблицы;

--Удаление индекса
DROP INDEX название_индекса;